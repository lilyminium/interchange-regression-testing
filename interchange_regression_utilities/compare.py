import re
from collections import defaultdict
from typing import Any, Dict, Generator, List, Optional, Tuple, Union

import numpy
from deepdiff import DeepDiff

from interchange_regression_utilities.models import (
    ComparisonSettings,
    ExpectedDifference,
    ExpectedValueChange,
)


def _values_from_openmm_system(
    parent_value: Union[Any, List[Any], Dict[str, Any]],
    parent_name: Optional[Union[int, str]],
    parent_deepdiff_path: List[str],
    current_path: List[str],
) -> Generator[Tuple[str, Any], None, None]:

    if current_path[0] != "*":
        attribute_names = [current_path[0]]
    else:

        if parent_value is None:
            return
        elif not isinstance(parent_value, (dict, list)):
            raise NotImplementedError()

        attribute_names = list(
            range(len(parent_value)) if isinstance(parent_value, list) else parent_value
        )

    if parent_name == "Forces":

        if current_path[0] == "*":
            raise NotImplementedError()

        expected_attribute_names = list(attribute_names)

        attribute_names = [
            i
            for attribute_name in attribute_names
            for i, item in enumerate(parent_value)
            if item["type"] == attribute_name
        ]

        if len(attribute_names) == 0:
            raise KeyError(f"{expected_attribute_names} not found")

    for attribute_name in attribute_names:

        attribute = parent_value[
            int(attribute_name) if isinstance(parent_value, list) else attribute_name
        ]
        attribute_path = parent_deepdiff_path + [
            f"['{attribute_name}']"
            if isinstance(attribute_name, str)
            else f"[{attribute_name}]"
        ]

        if len(current_path) == 1:
            yield "".join(attribute_path), attribute
        else:
            next_path = current_path[1:]

            for value in _values_from_openmm_system(
                attribute,
                attribute_name,
                attribute_path,
                next_path,
            ):
                yield value


def values_from_openmm_system(
    openmm_system: Dict[str, Any],
    openmm_path: Optional[str],
    deepdiff_path: Optional[str] = None,
) -> List[Tuple[str, Any]]:
    """Returns all the values from a dictionary representation of an OpenMM system
    (see ``load_openmm_system_as_dict``) that match a given 'selector' path
    (see ``deepdiff_path_to_openmm_path``).
    """

    assert (openmm_path is None and deepdiff_path is not None) or (
        openmm_path is not None and deepdiff_path is None
    ), "exactly one of 'openmm_path' and 'deepdiff_path' must be specified"

    if deepdiff_path is not None:
        from deepdiff.path import extract

        return [(deepdiff_path, extract(openmm_system, deepdiff_path))]

    openmm_path_split = openmm_path.strip("/").split("/")
    return [
        *_values_from_openmm_system(openmm_system, None, ["root"], openmm_path_split)
    ]


def deepdiff_path_to_openmm_path(
    openmm_system: Dict[str, Any], deepdiff_path: str, index_to_wildcard: bool = True
):
    """Converts a 'path' to the attribute in an object generated by DeepDiff to a more
    readable and comprehensible 'path' to a field in an XML serialized OpenMM system.

    For example:

    * ``"root['Particles'][i]['mass']"``    -> "Particles/*/mass"
    * ``"root['Forces'][i]['Bonds'][j]['k'] -> "Forces/HarmonicBondForce/Bonds/*/k"
    * ``"root['Forces'][i]['cutoff']        -> "Forces/NonbondedForce/cutoff"
    * ``"root['Forces'][i]['Particles'][j]  >  "Forces/NonbondedForce/Particles/*"
    """

    assert deepdiff_path.startswith("root")

    openmm_path = deepdiff_path[5:].replace("][", "/").replace("'", "").rstrip("]")

    if openmm_path.startswith("Forces"):

        force_matches = re.findall(r"Forces/(\d+?)/", openmm_path)
        assert len(force_matches) == 1

        [force_match] = force_matches

        force_index = int(force_match)
        force_type = openmm_system["Forces"][force_index]["type"]

        openmm_path = openmm_path.replace(
            f"Forces/{force_index}/", f"Forces/{force_type}/"
        )

    if index_to_wildcard:
        openmm_path = re.sub(r"/\d+?/", "/*/", openmm_path)

    return openmm_path


def _differences_of_type(
    differences: DeepDiff,
    difference_type: str,
    system_a: Dict[str, Any],
    system_b: Dict[str, Any],
) -> Dict[Tuple[str, str], Dict[str, Any]]:
    """Returns all fields of ``differences[difference_type]`` in a dictionary of the
    form ``differences_by_type[(deepdiff_path, openmm_path)] = difference"""

    differences_by_type = {}

    for deepdiff_path, difference in differences.get(difference_type, {}).items():

        openmm_path_a = deepdiff_path_to_openmm_path(system_a, deepdiff_path)
        openmm_path_b = deepdiff_path_to_openmm_path(system_b, deepdiff_path)

        assert openmm_path_a == openmm_path_b
        openmm_path = openmm_path_a

        differences_by_type[(deepdiff_path, openmm_path)] = difference

    return differences_by_type


def compare_numeric_value_changes(
    differences: DeepDiff,
    system_a: Dict[str, Any],
    system_b: Dict[str, Any],
    settings: ComparisonSettings,
):
    """A helper method to compare the absolute differences between numeric values
    that is applied on type of the standard ``DeepDiff`` significant figure check.
    """

    value_changes_to_ignore = set()
    n_numeric_warnings = defaultdict(int)

    for (deepdiff_path, openmm_path), difference in _differences_of_type(
        differences, "values_changed", system_a, system_b
    ).items():

        try:
            old_value = float(difference["old_value"])
            new_value = float(difference["new_value"])
        except (ValueError, TypeError):
            # These are not numeric values
            continue

        delta = abs(new_value - old_value)

        override_tolerance = settings.numeric_tolerance_overrides.get(openmm_path, None)

        less_than_default = delta < settings.default_numeric_tolerance
        less_than_override = (
            None if override_tolerance is None else (delta < override_tolerance)
        )

        if (
            less_than_override is not None
            and less_than_override is True
            and less_than_default is False
        ):
            n_numeric_warnings[openmm_path] += 1

        if (less_than_override is not None and less_than_override is True) or (
            less_than_override is None and less_than_default is True
        ):
            value_changes_to_ignore.add(deepdiff_path)

    for deepdiff_path in value_changes_to_ignore:
        del differences["values_changed"][deepdiff_path]

    if "values_changed" in differences and len(differences["values_changed"]) == 0:
        del differences["values_changed"]

    warning_messages = []

    if len(n_numeric_warnings) > 0:

        for openmm_path, n_counts in n_numeric_warnings.items():

            warning_messages.append(
                f"{n_counts} values matching {openmm_path} were different by <"
                f"{settings.numeric_tolerance_overrides[openmm_path]} but >"
                f"{settings.default_numeric_tolerance}",
            )

    return warning_messages


def check_expected_value_changes(
    differences: DeepDiff,
    system_a: Dict[str, Any],
    system_b: Dict[str, Any],
    expected_differences: List[ExpectedValueChange],
) -> List[str]:
    """Checks that any expected value changes did indeed occur, and stores any that
    did not in a ``values_unchanged`` field of ``differences`` while removing any
    expected ones from ``values_changed``.
    """

    value_changes = differences.get("values_changed", {})

    missing_differences = defaultdict(dict)

    for expected_difference in expected_differences:

        values_a = list(
            values_from_openmm_system(
                system_a,
                expected_difference.openmm_path,
                expected_difference.deepdiff_path,
            )
        )
        values_b = list(
            values_from_openmm_system(
                system_b,
                expected_difference.openmm_path,
                expected_difference.deepdiff_path,
            )
        )

        assert len(values_a) > 0 and len(values_a) == len(values_b)

        for (old_path, old_value), (new_path, new_value) in zip(values_a, values_b):

            assert old_path == new_path

            if isinstance(old_value, float) or isinstance(new_value, float):
                as_expected = numpy.isclose(
                    old_value, expected_difference.old_value
                ) and numpy.isclose(new_value, expected_difference.new_value)
            else:
                as_expected = (
                    old_value == expected_difference.old_value
                    and new_value == expected_difference.new_value
                )

            value_changes.pop(old_path, None)

            if as_expected:
                continue

            expected_path = (
                expected_difference.openmm_path
                if expected_difference.openmm_path
                else expected_difference.deepdiff_path
            )

            missing_differences[expected_path][old_path] = {
                "expected_old_value": expected_difference.old_value,
                "old_value": old_value,
                "expected_new_value": expected_difference.new_value,
                "new_value": new_value,
            }

    if len(value_changes) == 0:
        differences.pop("values_changed", None)
    if len(missing_differences) > 0:
        differences["values_unchanged"] = {**missing_differences}

    warning_messages = []
    return warning_messages


def compare_openmm_system_differences(
    system_a: Dict[str, Any],
    system_b: Dict[str, Any],
    settings: ComparisonSettings,
    expected_differences: List[ExpectedDifference],
) -> Tuple[DeepDiff, List[str]]:
    """Compares two OpenMM system objects that have been converted to dictionaries
    using ``load_openmm_system_as_dict``."""

    differences = DeepDiff(
        system_a,
        system_b,
        ignore_order=False,
        ignore_numeric_type_changes=True,
        ignore_string_type_changes=True,
        significant_digits=6,
    )

    if {*differences} != {"values_changed"} and {*differences} != set():
        return differences, [
            "numeric and expected change checks skipped as there are differences other "
            "than value changes"
        ]

    warning_messages = [
        *compare_numeric_value_changes(differences, system_a, system_b, settings),
        # ...
    ]

    expected_differences_by_type = defaultdict(list)

    for expected_difference in expected_differences:

        expected_differences_by_type[expected_difference.type].append(
            expected_difference
        )

    warning_messages.extend(
        [
            *check_expected_value_changes(
                differences,
                system_a,
                system_b,
                expected_differences_by_type["value-changed"],
            ),
            # ...
        ]
    )

    return differences, warning_messages
